var documenterSearchIndex = {"docs":
[{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Cropbox is a domain-specific language (DSL) for Julia. To use Cropbox, you must first download and install Julia. For new users, it is recommended to install the \"Current stable release\" for Julia.","category":"page"},{"location":"installation/#Install-Cropbox","page":"Installation","title":"Install Cropbox","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Cropbox.jl is available through Julia package manager.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"Cropbox\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"There is a Docker image with Cropbox precompiled for convenience. By default, Jupyter Lab will be launched.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"$ docker run -it --rm -p 8888:8888 cropbox/cropbox","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If REPL is preferred, you can directly launch an instance of Julia session.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"$ docker run -it --rm cropbox/cropbox julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.1 (2021-04-23)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The docker image can be also launched via Binder without installing anything local.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(Image: Binder)","category":"page"},{"location":"tutorials/lotkavolterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"warning: Warning\nThis page is incomplete.","category":"page"},{"location":"tutorials/lotkavolterra/#Lotka-Volterra","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"","category":"section"},{"location":"guide/visualization/","page":"Visualization","title":"Visualization","text":"warning: Warning\nThis page is incomplete. Please check the Reference page for information regarding functions.","category":"page"},{"location":"guide/visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"guide/visualization/","page":"Visualization","title":"Visualization","text":"There are three main functions in Cropbox used for visualization.","category":"page"},{"location":"guide/visualization/","page":"Visualization","title":"Visualization","text":"Pages = [\"visualization.md\"]","category":"page"},{"location":"guide/visualization/#plot()","page":"Visualization","title":"plot()","text":"","category":"section"},{"location":"guide/visualization/","page":"Visualization","title":"Visualization","text":"The plot() function is used to plot a graph from a provided data source.","category":"page"},{"location":"guide/visualization/","page":"Visualization","title":"Visualization","text":"plot(df::DataFrame, x, y; <keyword arguments>) -> Plot\nplot(X::Vector, Y::Vector; <keyword arguments>) -> Plot\nplot(df::DataFrame, x, y, z; <keyword arguments>) -> Plot","category":"page"},{"location":"guide/visualization/#plot!","page":"Visualization","title":"plot!","text":"","category":"section"},{"location":"guide/visualization/#visualize()","page":"Visualization","title":"visualize()","text":"","category":"section"},{"location":"guide/visualization/","page":"Visualization","title":"Visualization","text":"visualize(<arguments>; <keyword arguments>) -> Plot","category":"page"},{"location":"guide/visualization/#visualize!","page":"Visualization","title":"visualize!","text":"","category":"section"},{"location":"guide/visualization/#manipulate()","page":"Visualization","title":"manipulate()","text":"","category":"section"},{"location":"reference/inspection/#Inspection","page":"Inspection","title":"Inspection","text":"","category":"section"},{"location":"reference/inspection/","page":"Inspection","title":"Inspection","text":"@look\ndive","category":"page"},{"location":"reference/inspection/#Cropbox.@look","page":"Inspection","title":"Cropbox.@look","text":"@look ex\n@look s[, k]\n\nMacro version of look supports a convenient way of accessing variable without relying on symbol. Both @look s.a and @look s a work the same as look(s, :a).\n\nSee also: look\n\nExamples\n\njulia> \"my system\"\n       @system S(Controller) begin\n           \"a param\"\n           a => 1 ~ preserve(parameter)\n       end;\n\njulia> @look S.a\n[doc]\n  a param\n\n[code]\n  a => 1 ~ preserve(parameter)\n\n\n\n\n\n","category":"macro"},{"location":"reference/inspection/#Cropbox.dive","page":"Inspection","title":"Cropbox.dive","text":"dive(s)\n\nInspect an instance of system s by navigating hierarchy of variables displayed in a tree structure.\n\nPressing up/down arrow keys allows navigation. Press 'enter' to dive into a deeper level and press 'q' to come back. A leaf node of the tree shows an output of look regarding the variable. Pressing 'enter' again would return a variable itself and exit to REPL.\n\nOnly works in a terminal environment; not working on Jupyter Notebook.\n\nSee also: look\n\nArguments\n\ns::System: instance of target system.\n\nExamples\n\njulia> @system S(Controller) begin\n           a => 1 ~ preserve(parameter)\n       end;\n\njulia> s = instance(S);\n\njulia> dive(s)\nS\n → context = <Context>\n   config = <Config>\n   a = 1.0\n\n\n\n\n\n","category":"function"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"warning: Warning\nThis page is incomplete.","category":"page"},{"location":"faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"guide/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In Cropbox, Config is a configuration object structured as a nested dictionary or a hash table. It stores user-defined parameter values as a triplet of system - variable - value. Providing a configuration object with specific parameter values during instantiation of a system allows the user to insert or replace values for parameter variables within the system. ","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"For a variable to be eligible for adjustment through a configuration, the variable must have the parameter tag. There are six possible variable states that have access to the parameter tag: preserve, flag, provide, drive, tabulate, and interpolate. The type of value that you assign in a configuration will vary depending on the variable state. For example, a configuration for a flag variable will contain an expression that can be evaluated as true or false.","category":"page"},{"location":"guide/configuration/#Creating-a-Configuration","page":"Configuration","title":"Creating a Configuration","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Configurations are created using the @config macro.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"using Cropbox\nusing DataFrames","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Example","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"@system S(Controller) begin\n    a => 1 ~ preserve(parameter)\nend\n\nconfig = @config(:S => :a => 2)\n\ninstance(S; config)","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"When the system is defined, the variable a is a preserve variable with the value of 1. Because the variable has a parameter tag, its value can be assigned with a configuration at instantiation.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"A configuration can be used to change the value of any parameter variable within the system. This includes parameters variables within built-in systems such as Clock and Calendar. ","category":"page"},{"location":"guide/configuration/#Changing-the-Time-Step","page":"Configuration","title":"Changing the Time Step","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"By default, a model simulation in Cropbox updates at an hourly interval. Based on your model, there may be times when you want to change the time step of the simulation. This too can be done using a configuration. In order to change the time step value, all we need is to assign a new value for step, which is simply a preserve variable with the parameter tag in the Clock system.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Example","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Here we create a simple system with an advance variable that simply starts at 0 and increases by 1.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"@system S(Controller) begin\n    a ~ advance\nend\n\nsimulate(S; stop=5u\"hr\")","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Configuring the step variable within the Clock system allows us to change the simulation to a daily interval.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"c = @config(:Clock => :step => 1u\"d\")\n\nsimulate(S; config=c, stop=5u\"d\")","category":"page"},{"location":"guide/configuration/#Supplying-a-DataFrame-to-a-provide-Variable","page":"Configuration","title":"Supplying a DataFrame to a provide Variable","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Apart from changing numerical parameter values, configurations are also commonly used to provide a new DataFrame to a provide variable that stores data for simulation. The syntax of the configuration remains identical, but instead of a numerical value, we provide a DataFrame. This allows us to easily run multiple simulations of a model using different datasets.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Example","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"@system S(Controller) begin\n    D ~ provide\nend\n\nconfig = @config(\n    :S => :D => DataFrame(index=(0:3)u\"hr\", value=0:10:30)\n)","category":"page"},{"location":"reference/visualization/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"reference/visualization/","page":"Visualization","title":"Visualization","text":"plot\nplot!\nvisualize\nvisualize!\nmanipulate","category":"page"},{"location":"reference/visualization/#Cropbox.plot","page":"Visualization","title":"Cropbox.plot","text":"plot(df::DataFrame, x, y; <keyword arguments>) -> Plot\nplot(X::Vector, Y::Vector; <keyword arguments>) -> Plot\nplot(df::DataFrame, x, y, z; <keyword arguments>) -> Plot\n\nPlot a graph from provided data source. The type of graph is selected based on arguments.\n\nSee also: plot!, visualize\n\n\n\n\n\nplot(v::Number; kind, <keyword arguments>) -> Plot\nplot(V::Vector; kind, <keyword arguments>) -> Plot\n\nPlot a graph of horizontal/vertical lines depending on kind, which can be either :hline or :vline. An initial plotting of hline requires xlim and vline requires ylim, respectively.\n\nSee also: plot!, visualize\n\n\n\n\n\n","category":"function"},{"location":"reference/visualization/#Cropbox.plot!","page":"Visualization","title":"Cropbox.plot!","text":"plot!(p, <arguments>; <keyword arguments>) -> Plot\n\nUpdate an existing Plot object p by appending a new graph made with plot.\n\nSee also: plot\n\nArguments\n\np::Union{Plot,Nothing}: plot object to be updated; nothing creates a new plot.\n\n\n\n\n\n","category":"function"},{"location":"reference/visualization/#Cropbox.visualize","page":"Visualization","title":"Cropbox.visualize","text":"visualize(<arguments>; <keyword arguments>) -> Plot\n\nMake a plot from an output collected by running necessary simulations. A convenient function to run both simulate and plot together.\n\nSee also: visualize!, simulate, plot, manipulate\n\nExamples\n\njulia> @system S(Controller) begin\n           a(a) => a ~ accumulate(init=1)\n       end;\n\njulia> visualize(S, :time, :a; stop=5, kind=:line)\n       ┌────────────────────────────────────────┐\n    32 │                                       :│\n       │                                      : │\n       │                                     :  │\n       │                                    :   │\n       │                                   :    │\n       │                                  :     │\n       │                                 :      │\n  a    │                                :       │\n       │                              .'        │\n       │                            .'          │\n       │                          .'            │\n       │                       ..'              │\n       │                   ..''                 │\n       │             ....''                     │\n     1 │.........''''                           │\n       └────────────────────────────────────────┘\n       0                                        5\n                      time (hr)\n\n\n\n\n\n","category":"function"},{"location":"reference/visualization/#Cropbox.visualize!","page":"Visualization","title":"Cropbox.visualize!","text":"visualize!(p, <arguments>; <keyword arguments>) -> Plot\n\nUpdate an existing Plot object p by appending a new graph made with visualize.\n\nSee also: visualize\n\nArguments\n\np::Union{Plot,Nothing}: plot object to be updated; nothing creates a new plot.\n\n\n\n\n\n","category":"function"},{"location":"reference/visualization/#Cropbox.manipulate","page":"Visualization","title":"Cropbox.manipulate","text":"manipulate(f::Function; parameters, config=())\n\nCreate an interactive plot updated by callback f. Only works in Jupyter Notebook.\n\nArguments\n\nf::Function: callback for generating a plot; interactively updated configuration c is provided.\nparameters: parameters adjustable with interactive widgets; value should be an iterable.\nconfig=(): a baseline configuration.\n\n\n\n\n\nmanipulate(args...; parameters, kwargs...)\n\nCreate an interactive plot by calling manipulate with visualize as a callback.\n\nSee also: visualize\n\nArguments\n\nargs: positional arguments for visualize.\nparameters: parameters for manipulate.\nkwargs: keyword arguments for visualize.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Index","title":"Index","text":"","category":"page"},{"location":"guide/inspection/","page":"Inspection","title":"Inspection","text":"warning: Warning\nThis page is incomplete. Please check the Reference page for information regarding functions.","category":"page"},{"location":"guide/inspection/#Inspection","page":"Inspection","title":"Inspection","text":"","category":"section"},{"location":"guide/inspection/","page":"Inspection","title":"Inspection","text":"There are two inspective functions in Cropbox that allow us to look at systems more closely.","category":"page"},{"location":"guide/inspection/","page":"Inspection","title":"Inspection","text":"Pages = [\"inspection.md\"]","category":"page"},{"location":"guide/inspection/#look()","page":"Inspection","title":"look()","text":"","category":"section"},{"location":"guide/inspection/","page":"Inspection","title":"Inspection","text":"look() provides a convenient way of accessing variables within a system.","category":"page"},{"location":"guide/inspection/","page":"Inspection","title":"Inspection","text":"look(s, :a)","category":"page"},{"location":"guide/inspection/","page":"Inspection","title":"Inspection","text":"!!! note \"Note\"     There is a macro version of this function, @look, which allows you to access a variable without using a symbol. Both @look s.a and @look s a are identical to look(s, :a).","category":"page"},{"location":"guide/inspection/#dive()","page":"Inspection","title":"dive()","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"warning: Warning\nThis page is incomplete. Please check the Reference page for information regarding functions.","category":"page"},{"location":"guide/simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"There are four different simulative functions in Cropbox that we can run with a model.","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"Pages = [\"simulation.md\"]","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"tip: Tip\nWhen running any simulative function, do not forget to include Controller as one of the mixins for the system that you which to simulate.","category":"page"},{"location":"guide/simulation/#instance()","page":"Simulation","title":"instance()","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"instance(S; <keyword arguments>) -> S","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"The instance function makes an instance of a system S with an initial condition specified by configuration and additional options.","category":"page"},{"location":"guide/simulation/#Keyword-Arguments","page":"Simulation","title":"Keyword Arguments","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"config=()","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"options=()","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"seed=nothing","category":"page"},{"location":"guide/simulation/#simulate()","page":"Simulation","title":"simulate()","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"simulate() runs a simulation by creating an instance of a specified system and updating it a specified number of times in order to generate an output in the form of a DataFrame.","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"simulate([f,] S[, layout, [configs]]; <keyword arguments>) -> DataFrame","category":"page"},{"location":"guide/simulation/#Arguments","page":"Simulation","title":"Arguments","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"S::Type{<:System}","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"layout::Vector","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"configs::Vector","category":"page"},{"location":"guide/simulation/#Keyword-Arguments-2","page":"Simulation","title":"Keyword Arguments","text":"","category":"section"},{"location":"guide/simulation/#Layout","page":"Simulation","title":"Layout","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"base=nothing","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"index=nothing","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"target=nothing","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"meta=nothing","category":"page"},{"location":"guide/simulation/#Configuration","page":"Simulation","title":"Configuration","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"config=()","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"configs=[]","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"seed=nothing","category":"page"},{"location":"guide/simulation/#Progress","page":"Simulation","title":"Progress","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"stop=nothing","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"snap=nothing","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"snatch=nothing","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"`verbose=true","category":"page"},{"location":"guide/simulation/#Format","page":"Simulation","title":"Format","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"nounit=false","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"long=false","category":"page"},{"location":"guide/simulation/#evaluate()","page":"Simulation","title":"evaluate()","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"evaluate(S, obs; <keyword arguments>) -> Number | Tuple","category":"page"},{"location":"guide/simulation/#calibrate()","page":"Simulation","title":"calibrate()","text":"","category":"section"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"calibrate(S, obs; <keyword arguments>) -> Config | OrderedDict","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"Cropbox includes a calibrate() function that helps determine parameter values based on a provided dataset. Internally, this process relies on BlackBoxOptim.jl for global optimization methods.","category":"page"},{"location":"guide/simulation/","page":"Simulation","title":"Simulation","text":"The calibrate() function returns a Config object that we can directly use in model simulations. ","category":"page"},{"location":"gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"gallery/","page":"Gallery","title":"Gallery","text":"Here are some models built using the Cropbox framework.","category":"page"},{"location":"gallery/#[CropRootBox.jl](https://github.com/cropbox/CropRootBox.jl)","page":"Gallery","title":"CropRootBox.jl","text":"","category":"section"},{"location":"gallery/#[Garlic.jl](https://github.com/cropbox/Garlic.jl)","page":"Gallery","title":"Garlic.jl","text":"","category":"section"},{"location":"gallery/#[LeafGasExchange.jl](https://github.com/cropbox/LeafGasExchange.jl)","page":"Gallery","title":"LeafGasExchange.jl","text":"","category":"section"},{"location":"gallery/#[SimpleCrop.jl](https://github.com/cropbox/SimpleCrop.jl)","page":"Gallery","title":"SimpleCrop.jl","text":"","category":"section"},{"location":"tutorials/gdd/","page":"Growing Degree-Day","title":"Growing Degree-Day","text":"warning: Warning\nThis page is incomplete.","category":"page"},{"location":"tutorials/gdd/#Growing-Degree-Day","page":"Growing Degree-Day","title":"Growing Degree-Day","text":"","category":"section"},{"location":"reference/simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"reference/simulation/","page":"Simulation","title":"Simulation","text":"instance\nsimulate\nevaluate\ncalibrate","category":"page"},{"location":"reference/simulation/#Cropbox.instance","page":"Simulation","title":"Cropbox.instance","text":"instance(S; <keyword arguments>) -> S\n\nMake an instance of system S with an initial condition specified in configuration and additional options.\n\nSee also: @config, simulate\n\nArguments\n\nS::Type{<:System}: type of system to be instantiated.\n\nKeyword Arguments\n\nconfig=(): configuration containing parameter values for the system.\noptions=(): keyword arguments passed down to the constructor of S; named tuple expected.\nseed=nothing: random seed initialized before parsing configuration and making an instance.\n\nExamples\n\njulia> @system S(Controller) begin\n           a => 1 ~ preserve(parameter)\n           b(a) ~ accumulate\n       end;\n\njulia> instance(S)\nS\n  context = <Context>\n  config = <Config>\n  a = 1.0\n  b = 0.0\n\n\n\n\n\n","category":"function"},{"location":"reference/simulation/#Cropbox.simulate","page":"Simulation","title":"Cropbox.simulate","text":"simulate([f,] S[, layout, [configs]]; <keyword arguments>) -> DataFrame\n\nRun simulations by making instance of system S with given configuration to generate an output in the form of DataFrame. layout contains a list of variables to be saved in the output. A layout of single simulation can be specified in the layout arguments placed as keyword arguments. configs contains a list of configurations for each run of simulation. Total number of simulation runs equals to the size of configs. For a single configuration, config keyword argument may be preferred. Optional callback function f allows do-block syntax to specify snatch argument for finer control of output format.\n\nSee also: instance, @config\n\nArguments\n\nS::Type{<:System}: type of system to be simulated.\nlayout::Vector: list of output layout definition in a named tuple (; base, index, target, meta).\nconfigs::Vector: list of configurations for defining multiple runs of simluations.\n\nKeyword Arguments\n\nLayout\n\nbase=nothing: base system where index and target are populated; default falls back to the instance of S.\nindex=nothing: variables to construct index columns of the output; default falls back to context.clock.time.\ntarget=nothing: variables to construct non-index columns of the output; default includes most variables in the root instance.\nmeta=nothing: name of systems in the configuration to be included in the output as metadata.\n\nConfiguration\n\nconfig=(): a single configuration for the system, or a base for multiple configurations (when used with configs).\nconfigs=[]: multiple configurations for the system.\nseed=nothing: random seed for resetting each simulation run.\n\nProgress\n\nstop=nothing: condition checked before calling updates for the instance; default stops with no update.\nsnap=nothing: condition checked to decide if a snapshot of current update is saved in the output; default snaps all updates.\nsnatch=nothing: callback for modifying intermediate output; list of DataFrame D collected from current update and the instance of system s are provided.\nverbose=true: shows a progress bar.\n\nFormat\n\nnounit=false: remove units from the output.\nlong=false: convert output table from wide to long format.\n\nExamples\n\njulia> @system S(Controller) begin\n           a => 1 ~ preserve(parameter)\n           b(a) ~ accumulate\n       end;\n\njulia> simulate(S; stop=1)\n2×3 DataFrame\n Row │ time       a        b\n     │ Quantity…  Float64  Float64\n─────┼─────────────────────────────\n   1 │    0.0 hr      1.0      0.0\n   2 │    1.0 hr      1.0      1.0\n\n\n\n\n\n","category":"function"},{"location":"reference/simulation/#Cropbox.evaluate","page":"Simulation","title":"Cropbox.evaluate","text":"evaluate(S, obs; <keyword arguments>) -> Number | Tuple\n\nCompare output of simulation results for the given system S and observation data obs with a choice of evaluation metric.\n\nArguments\n\nS::Type{<:System}: type of system to be evaluated.\nobs::DataFrame: observation data to be used for evaluation.\n\nKeyword Arguments\n\nConfiguration\n\nconfig=(): a single configuration for the system (can't be used with configs).\nconfigs=[]: multiple configurations for the system (can't be used with config).\n\nLayout\n\nindex=nothing: variables to construct index columns of the output; default falls back to context.clock.time.\ntarget: variables to construct non-index columns of the output.\n\nEvaluation\n\nmetric=nothing: evaluation metric (:rmse, :nrmse, :mae, :mape, :ef, :dr); default is RMSE.\n\nRemaining keyword arguments are passed down to simulate with regard to running system S.\n\nSee also: simulate, calibrate, @config\n\nExamples\n\njulia> @system S(Controller) begin\n           a => 19 ~ preserve(u\"m/hr\", parameter)\n           b(a) ~ accumulate(u\"m\")\n       end;\n\njulia> obs = DataFrame(time=10u\"hr\", b=200u\"m\");\n\njulia> configs = @config !(:S => :a => [19, 21]);\n\njulia> evaluate(S, obs; configs, target=:b, stop=10u\"hr\")\n10.0 m\n\n\n\n\n\nevaluate(obs, est; <keyword arguments>) -> Number | Tuple\n\nCompare observation data obs and estimation data est with a choice of evaluation metric.\n\nArguments\n\nobs::DataFrame: observation data to be used for evaluation.\nest::DataFrame: estimated data from simulation.\n\nKeyword Arguments\n\nLayout\n\nindex: variables referring to index columns of the output.\ntarget: variables referring to non-index columns of the output.\n\nEvaluation\n\nmetric=nothing: evaluation metric (:rmse, :nrmse, :mae, :mape, :ef, :dr); default is RMSE.\n\nSee also: evaluate\n\nExamples\n\njulia> obs = DataFrame(time = [1, 2, 3]u\"hr\", b = [10, 20, 30]u\"g\");\n\njulia> est = DataFrame(time = [1, 2, 3]u\"hr\", b = [10, 20, 30]u\"g\", c = [11, 19, 31]u\"g\");\n\njulia> evaluate(obs, est; index = :time, target = :b)\n0.0 g\n\njulia> evaluate(obs, est; index = :time, target = :b => :c)\n1.0 g\n\n\n\n\n\n","category":"function"},{"location":"reference/simulation/#Cropbox.calibrate","page":"Simulation","title":"Cropbox.calibrate","text":"calibrate(S, obs; <keyword arguments>) -> Config | OrderedDict\n\nObtain a set of parameters for the given system S that simulates provided observation obs closely as possible. A multitude of simulations are conducted with a differing combination of parameter sets specified by the range of possible values and the optimum is selected based on a choice of evaluation metric. Internally, differential evolution algorithm from BlackboxOptim.jl is used.\n\nArguments\n\nS::Type{<:System}: type of system to be calibrated.\nobs::DataFrame: observation data to be used for calibration.\n\nKeyword Arguments\n\nConfiguration\n\nconfig=(): a single base configuration for the system (can't be used with configs).\nconfigs=[]: multiple base configurations for the system (can't be used with config).\n\nLayout\n\nindex=nothing: variables to construct index columns of the output; default falls back to context.clock.time.\ntarget: variables to construct non-index columns of the output.\n\nCalibration\n\nparameters: parameters with a range of boundary values to be calibrated within.\nmetric=nothing: evaluation metric (:rmse, :nrmse, :mae, :mape, :ef, :dr); default is RMSE.\n\nMulti-objective\n\nweight=nothing: weights for calibrating multiple targets; default assumes equal weights.\npareto=false: returns a dictionary containing Pareto frontier instead of a single solution satisfying multiple targets.\n\nAdvanced\n\noptim=(): extra options for BlackBoxOptim.bboptimize.\n\nRemaining keyword arguments are passed down to simulate with regard to running system S.\n\nSee also: simulate, evaluate, @config\n\nExamples\n\njulia> @system S(Controller) begin\n           a => 0 ~ preserve(parameter)\n           b(a) ~ accumulate\n       end;\n\njulia> obs = DataFrame(time=10u\"hr\", b=200);\n\njulia> p = calibrate(S, obs; target=:b, parameters=:S => :a => (0, 100), stop=10)\n...\nConfig for 1 system:\n  S\n    a = 20.0\n\n\n\n\n\n","category":"function"},{"location":"guide/system/#System","page":"System","title":"System","text":"","category":"section"},{"location":"guide/system/","page":"System","title":"System","text":"In Cropbox, a system is a unit of model component that contains a collection of variables. The framework guarantees that the most current state of a variable is accessible by another variable that depends on said variable, provided that they are within the same system. To ensure a correct propagation of variable states, the system must have a linear order of computation that satisfies all the requirements for dependency imposed by variable declarations. Any inconsistency caused by a cyclic dependency between variables stops code generation and results in an error. This is intentional, as we want to avoid such logical errors from going through unnoticed. ","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"Once a system is defined, its structure is fixed and variables cannot be added or removed. The variables themselves, however, can still be updated throughout time steps. Variables declared in another system can be also accessed if the entire system holding dependent variables has already been updated. This is done by declaring an external system as a member of another system.","category":"page"},{"location":"guide/system/#Creating-a-System","page":"System","title":"Creating a System","text":"","category":"section"},{"location":"guide/system/","page":"System","title":"System","text":"A system in Cropbox is created through the Cropbox-specific macro, @system.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"@system name[{patches..}][(mixins..)] [<: type] [decl] -> Type{<:System}","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"@system declares a new system called name, with new variables declared in decl block using a custom syntax. mixins allow specifications of existing systems to be used for the new system. patches may provide type substitution and/or constant definition needed for advanced use. ","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"using Cropbox","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"Example","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"Here is an example of what a simple system may look like.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"@system begin\n    i => 1 ~ preserve\n    a => 0.1 ~ preserve(parameter)\n    r(a, x) => a*x ~ track\n    x(r) ~ accumulate(init = i)\nend","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"note: Note\nWe can use the Julia macro @macroexpand to see the expression generated by the @system macro.","category":"page"},{"location":"guide/system/#Mixin","page":"System","title":"Mixin","text":"","category":"section"},{"location":"guide/system/","page":"System","title":"System","text":"A mixin is a system that is included as a part another system. While each system implements its own set of variables, these variables can be linked with variables from other systems through the use of mixins.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"Example","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"Here is an example where the system S3 is declared with systems S1 and S2 as mixins.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"@system S1 begin\n    a => 1 ~ preserve(parameter)\n    b(a) => 2a ~ track\nend\n\n@system S2 begin\n    a => 2 ~ preserve(parameter)\n    b(a, c) => a*c ~ track\n    c => 1 ~ preserve\nend\n\n@system S3(S1, S2, Controller) begin\n    d(a) => 3a ~ preserve\nend\n\ninstance(S3)","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"note: Note\nThe order of mixins when creating a system is significant. When two variables from two different mixins share a name, the variable from the latter mixin in the system declaration will take priority over the first.","category":"page"},{"location":"guide/system/#Context","page":"System","title":"Context","text":"","category":"section"},{"location":"guide/system/","page":"System","title":"System","text":"Whenever a system is constructed in Cropbox, an internal variable named context referencing to an instance of a Context system is included by default. The purpose of the Context system is to manage the time and configuration of a system.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"This is what the Context system looks like.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"@system Context begin\n    context       ~ ::Nothing\n    config        ~ ::Config(override)\n    clock(config) ~ ::Clock\nend","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"The variables config and clock, referencing to the systems Config and Clock respectively, are necessary for system instantiation and thus included in every new system by default.","category":"page"},{"location":"guide/system/#Clock","page":"System","title":"Clock","text":"","category":"section"},{"location":"guide/system/","page":"System","title":"System","text":"Within the Context system, there is a clock variable referring to the Clock system. The Clock system is responsible for keeping track of time-related variables, namely init, step, time, and tick.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"This is what the Clock system looks like.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"abstract type Clock <: System end\ntimeunit(::Type{<:Clock}) = u\"hr\"\n@system Clock{timeunit = timeunit(Clock)} begin\n    context ~ ::Nothing\n    config ~ ::Config(override)\n    init => 0 ~ preserve(unit=timeunit, parameter)\n    step => 1 ~ preserve(unit=timeunit, parameter)\n    time => nothing ~ advance(init=init, step=step, unit=timeunit)\n    tick => nothing ~ advance::int\nend","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"time is an advance variable which is essentially an accumulate variable tailored for keeping time of simulation. By default, time starts at hour 0 and increases by 1-hour intervals. tick is another time variable that is responsible for keeping track of the number of updates performed. As a result, context.clock.time and context.clock.tick are often used as the index for the x-axis of plots and visualizations. ","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"The step variable is a preserve variable that determines the time-step intervals of a simulation. As we can see, step also happens to be a parameter, which means that it can be altered through a configuration.","category":"page"},{"location":"guide/system/#Config","page":"System","title":"Config","text":"","category":"section"},{"location":"guide/system/","page":"System","title":"System","text":"Unlike the Clock system, the Config referred to by the config variable in Context is not a system. Config is a configuration object structured as a nested dictionary or hash table to store user-defined parameter values as a triplet of system - variable - value. When a configuration object containing specified parameter values are provided to a instantiation of a system, the corresponding variables in the system with the tag parameter will have the configuration values plugged in.","category":"page"},{"location":"guide/system/#Controller","page":"System","title":"Controller","text":"","category":"section"},{"location":"guide/system/","page":"System","title":"System","text":"An instance of context and configuration provided to an instance of a new system is usually sourced by a parent system that holds a variable referring to that system. However, because there is no parent system for the instantiation of the first system, context and configuration need to be supplied elsewhere. Controller is pre-built system of Cropbox made to handle such issues by creating an instance of Context by itself.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"This is what the Controller system looks like.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"@system Controller begin\n    config ~ ::Config(override)\n    context(config) ~ ::Context(context)\nend","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"The Config object referred to by the config variable is overridden by a keyword argument (config) of the system constructor instance() and functions such as simulate() and visualize(). Therefore at least one (and usually only one) system is designated to possess Controller as one of its mixins. In order to run an instance or a simulation of a system, Controller must be included as a mixin. Unlike the system Context, Controller is not a built-in mixin and must be explicitly declared as a mixin when declaring a system.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"tip: Tip\nWhen you create a system that you want to instantiate, make sure to have Controller as a mixin. You can also make a system instantiable by making a new system with Controller and the original system as mixins.","category":"page"},{"location":"guide/system/#Calendar","page":"System","title":"Calendar","text":"","category":"section"},{"location":"guide/system/","page":"System","title":"System","text":"Calendar is a system similar to the Clock system that is embedded in Context. Calendar provides time and step variables, but in the type of ZonedDateTime from TimeZones.jl. Much like Clock, Calendar is a pre-built Cropbox system, but is not included by default as a variable reference like context for the system Context.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"This is what the Calendar system looks like.","category":"page"},{"location":"guide/system/","page":"System","title":"System","text":"@system Calendar begin\n    init ~ preserve::datetime(extern, parameter)\n    last => nothing ~ preserve::datetime(extern, parameter, optional)\n    time(t0=init, t=context.clock.time) => t0 + convert(Cropbox.Dates.Second, t) ~ track::datetime\n    date(time) => Cropbox.Dates.Date(time) ~ track::date\n    step(context.clock.step) ~ preserve(u\"hr\")\n    stop(time, last) => begin\n        isnothing(last) ? false : (time >= last)\n    end ~ flag\n    count(init, last, step) => begin\n        if isnothing(last)\n            nothing\n        else\n            # number of update!() required to reach `last` time\n            (last - init) / step\n        end\n    end ~ preserve::int(round, optional)\nend","category":"page"},{"location":"reference/declaration/#Declaration","page":"Declaration","title":"Declaration","text":"","category":"section"},{"location":"reference/declaration/","page":"Declaration","title":"Declaration","text":"@system\n@config","category":"page"},{"location":"reference/declaration/#Cropbox.@system","page":"Declaration","title":"Cropbox.@system","text":"@system name[{patches..}][(mixins..)] [<: type] [decl] -> Type{<:System}\n\nDeclare a new system called name with new variables declared in decl block using a custom syntax. The resultant system is subtype of System or a custom type. mixins allows reusing specification of existing systems to be pasted into the declaration of new system. patches may provide type substitution and/or constant definition needed for advanced use.\n\nVariable\n\nname[(args..; kwargs..)][: alias] [=> expr] [~ [state][::type|<:type][(tags..)]]\n\nname: variable name; usually short abbreviation.\nargs: automatically bound depending variables\nkwargs: custom bound depending variables; used by call and integrate.\nalias: alternative name; long description.\nexpr: state-specific code snippet; use begin-end block for multiple statements.\ntype: internal data type; default is Float64 for many, but not all, variables.\ntags: state-specific options; unit, min/max, etc.\n\nStates\n\nhold: marks a placeholder for variable shared between mixins.\nwrap: passes a state variable to other fucnction as is with no unwrapping its value.\nadvance: manages a time-keeping variable; time and tick from Clock.\npreserve: keeps initially assigned value with no further updates; constants, parameters.\ntabulate: makes a two dimensional table with named keys; i.e. partitioning table.\ninterpolate: makes a curve function interpolated with discrete values; i.e. soil characteristic curve.\ntrack: evaluates variable expression as is for each update.\nremember: keeps tracking variable until a certain condition is met; essentially track turning into preserve.\nprovide: manages a table of time-series in DataFrame.\ndrive: fetches the current value from a time-series; maybe supplied by provide.\ncall: defines a partial function bound with some variables.\nintegrate: calculates integral using Gaussian method; not for time domain.\naccumulate: emulates integration of rate variable over time; essentially Euler method.\ncapture: calculates difference between integration for each time step.\nflag: sets a boolean flag; essentially track::Bool.\nproduce: attaches a new instance of system dynamically constructed; i.e. root structure growth.\nbisect: solves nonlinear equation using bisection method; i.e. gas-exchange model coupling.\nsolve: solves polynomial equation symbolically; i.e. quadratic equations in photosynthesis model.\n\nExamples\n\njulia> @system S(Controller) begin\n           a => 1 ~ preserve(parameter)\n           b(a) ~ accumulate\n       end\nS\n\n\n\n\n\n","category":"macro"},{"location":"reference/declaration/#Cropbox.@config","page":"Declaration","title":"Cropbox.@config","text":"@config c.. -> Config | Vector{Config}\n\nConstruct a set or multiple sets of configuration.\n\nA basic unit of configuration for a system S is represented by a pair in the form of S => pv. System name S is expressed in a symbol. If actual type of system is used, its name will be automatically converted to a symbol.\n\nA parameter name and corresponding value is then represented by another pair in the form of p => v. When specifiying multiple parameters, a tuple of pairs like (p1 => v1, p2 => v2) or a named tuple like (p1 = v1, p2 = v2) can be used. Parameter name must be a symbol and should indicate a variable declared with parameter tag as often used by preserve state variable. For example, :S => (:a => 1, :b => 2) has the same meaning as S => (a = 1, b = 2) in the same scope.\n\nConfigurations for multiple systems can be concatenated by a tuple. Multiple elements in c separated by commas implicitly forms a tuple. For example, :S => (:a => 1, :b => 2), :T => :x => 1 represents a set of configuration for two systems S and T with some parameters. When the same names of system or variable appears again during concatenation, it will be overriden by later ones in an order appeared in a tuple. For example, :S => :a => 1, :S => :a => 2 results into :S => :a => 2. Instead of commas, + operator can be used in a similar way as (:S => :a => 1) + (:S => :a => 2). Note parentheses placed due to operator precedence.\n\nWhen multiple sets of configurations are needed, as in configs for simulate, a vector of Config is used. This macro supports some convenient ways to construct a vector by composing simpler configurations. Prefix operator ! allows expansion of any iterable placed in the configuration value. Infix operator * allows multiplication of a vector of configurations with another vector or a single configuration to construct multiple sets of configurations. For example, !(:S => :a => 1:2) is expanded into two sets of separate configurations [:S => :a => 1, :S => :a => 2]. (:S => :a => 1:2) * (:S => :b => 0) is multiplied into [:S => (a = 1, b = 0), :S => (a = 2, b = 0)].\n\nExamples\n\njulia> @config :S => (:a => 1, :b => 2)\nConfig for 1 system:\n  S\n    a = 1\n    b = 2\n\njulia> @config :S => :a => 1, :S => :a => 2\nConfig for 1 system:\n  S\n    a = 2\n\njulia> @config !(:S => :a => 1:2)\n2-element Vector{Config}:\n <Config>\n <Config>\n\njulia> @config (:S => :a => 1:2) * (:S => :b => 0)\n2-element Vector{Config}:\n <Config>\n <Config>\n\n\n\n\n\n","category":"macro"},{"location":"#Cropbox","page":"Cropbox","title":"Cropbox","text":"","category":"section"},{"location":"#What-is-Cropbox?","page":"Cropbox","title":"What is Cropbox?","text":"","category":"section"},{"location":"","page":"Cropbox","title":"Cropbox","text":"Cropbox is a declarative modeling framework specifically designed for developing crop models. The goal is to let crop modelers focus on what the model should look like rather than how the model is technically implemented under the hood.","category":"page"},{"location":"#Getting-started","page":"Cropbox","title":"Getting started","text":"","category":"section"},{"location":"","page":"Cropbox","title":"Cropbox","text":"Read the Installation section.\nRead the Guide to understand the structure of models within Cropbox.\nRead the Tutorials for building your own model with Cropbox.\nCheck out the Gallery to see what others have done with the Cropbox framework.","category":"page"},{"location":"#Documentation-Outline","page":"Cropbox","title":"Documentation Outline","text":"","category":"section"},{"location":"","page":"Cropbox","title":"Cropbox","text":"Guide contains short explanations of performing specific tasks in Cropbox.","category":"page"},{"location":"","page":"Cropbox","title":"Cropbox","text":"Tutorials contains detailed walkthroughs for creating your own model with Cropbox.","category":"page"},{"location":"","page":"Cropbox","title":"Cropbox","text":"Reference contains a complete list of the macros and functions utilized in Cropbox.","category":"page"},{"location":"","page":"Cropbox","title":"Cropbox","text":"Gallery includes a list of models created using the Cropbox framework.","category":"page"},{"location":"","page":"Cropbox","title":"Cropbox","text":"Frequently Asked Questions section includes answers to common questions that have been asked by users of Cropbox.","category":"page"},{"location":"#Citation","page":"Cropbox","title":"Citation","text":"","category":"section"},{"location":"","page":"Cropbox","title":"Cropbox","text":"When using Cropbox in your work, please consider citing the following...","category":"page"},{"location":"guide/variable/#Variables","page":"Variable","title":"Variables","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"In Cropbox, a variable is defined as a unit element of modeling that denotes a value determined by a specific operation relying on other variables. Each variable represents a field within the system struct defined by the @system macro.","category":"page"},{"location":"guide/variable/#Variable-Declaration","page":"Variable","title":"Variable Declaration","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Variables are declared when a system is declared with the @system macro. @system macro accepts lines of variable declaration specified by its own syntax. They are loosely based on Julia syntax sharing common expressions and operators, but have distinct semantics as explained below.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"name[(args..; kwargs..)][: alias] [=> body] ~ [state][::type][(tags..)]","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"name: variable name (usually short abbreviation)\nargs: automatically bound depending variables\nkwargs: custom bound depending variables (only for call now)\nalias: alternative name (long description)\nbody: code snippet (state/type specific, begin .. end block for multiple lines)\nstate: verb indicating kind of state (empty if not State-based)\ntype: internal type (i.e. Float64 by default for most State variable)\ntags: variable specific options (i.e. unit, min/max, etc.)","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"using Cropbox\nusing DataFrames","category":"page"},{"location":"guide/variable/#State","page":"Variable","title":"State","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Within Cropbox, a variable inside a system can be one of many different abstract types based on the variable's purpose. Depending on its type, each variable has its own behavior when a system is instantiated. In Cropbox, we refer to these as the state of the variables, originating from the term state variables often used in mathematical modeling.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"note: Note\nSpecifying a state is not mandatory when declaring a variable. Cropbox also allows plain variables, which are commonly used for creating variable references to other systems.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Currently, there are 19 different variable states implemented in Cropbox.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Instant derivation","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"preserve: keeps an initially assigned value with no further updates; constants, parameters\ntrack : evaluates expression and assigns a new value for each time step\nflag : checks a conditional logic; similar to track with boolean type, but composition is allowed\nremember : keeps tracking the variable until a certain condition is met; like track switching to preserve","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Cumulative update","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"accumulate: emulates integration of a rate variable over time; essentially Euler method\ncapture : calculates the difference of accumulate between time steps\nintegrate : calculates an integral over a non-time variable using Gaussian method\nadvance : updates an internal time-keeping variable","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Data source","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"provide : provides a table-like multi-column time-series data; i.e. weather data\ndrive : fetches the current value from a time-series; often used with provide; i.e. air temperature\ntabulate : makes a two dimensional table with named keys; i.e. partitioning table\ninterpolate : makes a curve function interpolated with discrete values; i.e. soil characteristic curve","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Equation solving","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"solve : solves a polynomial equation symbolically; i.e. quadratic equation for coupling photosynthesis\nbisect : solves a nonlinear equation using bisection method; i.e. energy balance equation","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Dynamic structure","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"produce : attaches a new instance of dynamically generated system; i.e. root structure growth","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Language extension","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"hold: marks a placeholder for the variable shared between mixins\nwrap : allows passing a reference to the state variable object, not a dereferenced value\ncall : defines a partial function accepting user-defined arguments, while bound to other variables\nbring : duplicates variables declaration from another system into the current system","category":"page"},{"location":"guide/variable/#*Instant-derivation*","page":"Variable","title":"Instant derivation","text":"","category":"section"},{"location":"guide/variable/#preserve","page":"Variable","title":"preserve","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"preserve variables are fixed values with no further modification after instantiation of a system. Consequently, they are often used as the state for parameter variables, which allow any initial value to be set via a configuration object supplied at the start of a simulation. Non-parameter constants are also used for fixed variables that do not need to be computed at each time step.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    a => 1 ~ preserve\nend\n\nsimulate(S; stop=3u\"hr\")","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit, optional, parameter, override, extern, ref, min, max, round","category":"page"},{"location":"guide/variable/#track","page":"Variable","title":"track","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"track variables are evaluated and assigned a new value at every time step. In a conventional model, these are the variables that would be computed in every update loop. At every time step, the formula in the variable code is evaluated and saved for use. This assignment of value occurs only once per time step, as intended by the Cropbox framework. No manual assignment of computation at an arbitrary time is allowed. This is to ensure that that there are no logical errors resulting from premature or incorrectly ordered variable assignments. For example, a cyclical reference between two track variables is caught by Cropbox as an error. In many procedural programming languages, such logical errors are still valid and go unnoticed even after model completion.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"In this example, we can see that the variable b keeps track of the most recent iteration of the variable a.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    a => 1 ~ accumulate\n    b(a) => a ~ track\nend\n\nsimulate(S; stop=3u\"hr\")","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit, override, extern, ref, skip, init, min, max, round, when","category":"page"},{"location":"guide/variable/#flag","page":"Variable","title":"flag","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"flag variables are expressed in a conditional statement or logical operator for which a boolean value is evaluated at every time step. They function like a track variable but with a boolean value.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"In this example, the FLAG variable evaluates a > b and saves the resulting boolean value at each time step.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    a => 1 ~ accumulate\n    b => 2 ~ preserve\n\n    FLAG(a, b) => (a > b) ~ flag\nend\n\nsimulate(S; stop=3u\"hr\")","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: parameter, override, extern, once, when","category":"page"},{"location":"guide/variable/#remember","page":"Variable","title":"remember","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"remember variables are values that are evaluated until a specified condition is met. They are like track variables that turn into preserve variables.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    t(context.clock.tick) ~ track\n    w(t) => t >= 2 ~ flag\n    i => -1 ~ preserve\n    r(t) ~ remember(init=i, when=w)\nend\n\nsimulate(S; stop=3u\"hr\")","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit, init, when","category":"page"},{"location":"guide/variable/#*Cumulative-update*","page":"Variable","title":"Cumulative update","text":"","category":"section"},{"location":"guide/variable/#accumulate","page":"Variable","title":"accumulate","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"accumulate variables emulate the integration of a rate variable over time. It uses the Euler's method of integration. By default, an accumulate variable accumulates every hour, unless a time unit is specified.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"In this example, both a and `b are accumulate variables that increase by 1. Because b has a time unit of u\"d\" specified, it accumulates at 1/24 the rate of a.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    a => 1 ~ accumulate\n    b => 1 ~ accumulate(u\"d\")\nend\n\nsimulate(S; stop=3u\"hr\")","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit, init, time, timeunit, reset, min, max, when","category":"page"},{"location":"guide/variable/#*Data-source*","page":"Variable","title":"Data source","text":"","category":"section"},{"location":"guide/variable/#provide","page":"Variable","title":"provide","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"provide variables provide a DataFrame with a given index (index) starting from an initial value (init).","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    D => DataFrame(index=(0:3)u\"hr\", value=0:10:30) ~ provide\nend\n\ninstance(S)","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: index, init, step, autounit, parameter","category":"page"},{"location":"guide/variable/#drive","page":"Variable","title":"drive","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"drive variables fetch the current value from a time-series. It is often used in conjunction with provide.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    a => [2, 4, 6] ~ drive\nend\n\ninstance(S)","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: tick, unit, from, by, parameter, override","category":"page"},{"location":"guide/variable/#tabulate","page":"Variable","title":"tabulate","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"tabulate variables make a two dimensional table with named keys.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    T => [\n      # a b\n        0 4 ; # A\n        1 5 ; # B\n        2 6 ; # C \n        3 7 ; # D\n    ] ~ tabulate(rows=(:A, :B, :C, :D), columns=(:a, :b))\nend","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit, rows, columns, parameter","category":"page"},{"location":"guide/variable/#interpolate","page":"Variable","title":"interpolate","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"interpolate variables make a curve function for a provided set of discrete values.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    m => ([1 => 10, 2 => 20, 3 => 30]) ~ interpolate\n    n(m) ~ interpolate(reverse)\n    a(m) => m(2.5) ~ track\n    b(n) => n(25) ~ track\nend\n\nsimulate(S; stop=3u\"hr\")","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit, knotunit, reverse, parameter","category":"page"},{"location":"guide/variable/#*Equation-solving*","page":"Variable","title":"Equation solving","text":"","category":"section"},{"location":"guide/variable/#solve","page":"Variable","title":"solve","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"solve variables solve a polynomial equation symbolically.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    a => 1 ~ preserve(parameter)\n    b => 2 ~ preserve(parameter)\n    c => 4 ~ preserve(parameter)\n    x(a, b, c) => begin\n        a*x^2 + b*x + c\n    end ~ solve\nend\n\ninstance(S)","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit, lower, upper, pick","category":"page"},{"location":"guide/variable/#bisect","page":"Variable","title":"bisect","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"bisect variables solve a nonlinear equation using the bisection method.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S(Controller) begin\n    x(x) => x - 1 ~ bisect(lower=0, upper=2)\nend\n\ninstance(S)","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit, evalunit, lower, upper, maxiter, tol, min, max","category":"page"},{"location":"guide/variable/#*Dynamic-structure*","page":"Variable","title":"Dynamic structure","text":"","category":"section"},{"location":"guide/variable/#produce","page":"Variable","title":"produce","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"produce variables attach a new instance of a dynamically generated system.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"In this example, we produce a system S which we can reference with a new variable in another system.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S begin\n    a => produce(S) ~ produce\nend\n\n@system SController(Controller) begin\n    s(context) ~ ::S\nend","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: single, when","category":"page"},{"location":"guide/variable/#*Language-extension*","page":"Variable","title":"Language extension","text":"","category":"section"},{"location":"guide/variable/#hold","page":"Variable","title":"hold","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"hold variables are placeholders for variables that are supplied by another system as a mixin.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"In S2, using a as a hold variable allows us to declare b which depends on a for evaluation. Using S1 as a mixin for S2 actually allows us to instantiate S2 because S1 contains an advance variable a.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"@system S1 begin\n    a ~ advance\nend\n\n@system S2(S1, Controller) begin\n    a ~ hold\n    b(a) => a ~ track\nend\n\nsimulate(S2; stop=3u\"hr\")","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: None","category":"page"},{"location":"guide/variable/#wrap","page":"Variable","title":"wrap","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"wrap allows passing a reference to the state variable object, not a dereferenced value","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: None","category":"page"},{"location":"guide/variable/#call","page":"Variable","title":"call","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"call defines a partial function accepting user-defined arguments","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: unit","category":"page"},{"location":"guide/variable/#bring","page":"Variable","title":"bring","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"bring duplicates variable declaration from another system into the current system","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Supported tags: parameters, override","category":"page"},{"location":"guide/variable/#Tag","page":"Variable","title":"Tag","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Apart from a few, most variable states have tags that can be specified in the form of (tag) to add additional features. The available tags vary between variable states. Some tags are shared by multiple variable states while some tags are exclusive to certain variable states.","category":"page"},{"location":"guide/variable/#autounit","page":"Variable","title":"autounit","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"autounit tag allows provide variables to automatically assign units to variables depending on column headers of the DataFrame.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: provide","category":"page"},{"location":"guide/variable/#by","page":"Variable","title":"by","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"by tag is used to specify which column and series from which the drive variable should be driven.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: drive","category":"page"},{"location":"guide/variable/#columns","page":"Variable","title":"columns","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"columns","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: tabulate","category":"page"},{"location":"guide/variable/#evalunit","page":"Variable","title":"evalunit","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"evalunit","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: bisect","category":"page"},{"location":"guide/variable/#extern","page":"Variable","title":"extern","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"extern","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve, track, flag","category":"page"},{"location":"guide/variable/#from","page":"Variable","title":"from","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"from tag is used to specify the DataFrame that the drive variable will be driven from.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: drive","category":"page"},{"location":"guide/variable/#index","page":"Variable","title":"index","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"index, combined with init, is used by provide variables to specify the index and initial value of the DataFrame from which the data will be provided.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: provide","category":"page"},{"location":"guide/variable/#init","page":"Variable","title":"init","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"init assigns the first value to be used for the variable at the time of instantiation.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"init","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: track, remember, accumulate, provide","category":"page"},{"location":"guide/variable/#knotunit","page":"Variable","title":"knotunit","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"knotunit","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: interpolate","category":"page"},{"location":"guide/variable/#lower","page":"Variable","title":"lower","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"lower tag is used to specify the lower bound of the solution for solve and bisect variables.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: solve, bisect","category":"page"},{"location":"guide/variable/#max","page":"Variable","title":"max","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"max Determines the minimum possible value of variable evaluation.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve, track, accumulate, bisect","category":"page"},{"location":"guide/variable/#maxiter","page":"Variable","title":"maxiter","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"maxiter tag defines the maximum number of iterations for the","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: bisect","category":"page"},{"location":"guide/variable/#min","page":"Variable","title":"min","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"min Determines the minimum possible value of variable evaluation.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve, track, accumulate, bisect","category":"page"},{"location":"guide/variable/#optional","page":"Variable","title":"optional","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve","category":"page"},{"location":"guide/variable/#override","page":"Variable","title":"override","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"override","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve, track, flag, drive, bring","category":"page"},{"location":"guide/variable/#parameter","page":"Variable","title":"parameter","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Variables with the parameter tag can be altered with a configuration at the time of system instantiation.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve, flag, provide, drive, tabulate, interpolate","category":"page"},{"location":"guide/variable/#parameters","page":"Variable","title":"parameters","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"parameters","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: bring","category":"page"},{"location":"guide/variable/#pick","page":"Variable","title":"pick","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"pick","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: solve","category":"page"},{"location":"guide/variable/#ref","page":"Variable","title":"ref","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve, track","category":"page"},{"location":"guide/variable/#reset","page":"Variable","title":"reset","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"reset","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: accumulate","category":"page"},{"location":"guide/variable/#reverse","page":"Variable","title":"reverse","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"reverse","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: interpolate","category":"page"},{"location":"guide/variable/#round","page":"Variable","title":"round","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve, track","category":"page"},{"location":"guide/variable/#rows","page":"Variable","title":"rows","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"rows","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: tabulate","category":"page"},{"location":"guide/variable/#single","page":"Variable","title":"single","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"single","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: produce","category":"page"},{"location":"guide/variable/#step","page":"Variable","title":"step","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"step","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: provide","category":"page"},{"location":"guide/variable/#tick","page":"Variable","title":"tick","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"tick","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: drive","category":"page"},{"location":"guide/variable/#time","page":"Variable","title":"time","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"time","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: accumulate","category":"page"},{"location":"guide/variable/#timeunit","page":"Variable","title":"timeunit","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"timeunit","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: accumulate","category":"page"},{"location":"guide/variable/#tol","page":"Variable","title":"tol","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"tol","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: bisect","category":"page"},{"location":"guide/variable/#unit","page":"Variable","title":"unit","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"unit tag is used to specify the unit of the variable.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: preserve, track, remember, accumulate, drive, tabulate, interpolate, solve, bisect, call","category":"page"},{"location":"guide/variable/#upper","page":"Variable","title":"upper","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"upper tag is used to specify the upper bound of solution","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: solve, bisect","category":"page"},{"location":"guide/variable/#when","page":"Variable","title":"when","text":"","category":"section"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"when tag is used to specify when a variable should be evaluated. It is supplied with a flag variable, and the specified variable is only evaluated when the flag variable is true.","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Example","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"","category":"page"},{"location":"guide/variable/","page":"Variable","title":"Variable","text":"Used by: track, flag, remember, accumulate, produce","category":"page"}]
}
